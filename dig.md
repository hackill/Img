## 常见算法
* 对称加密 （单钥加密）

* 非对称加密 （双钥加密）

* 散列算法 （MD5, SHA1)

## 对称加密
```
1、常见的对称加密
   AES DES 3DES 等

2、历史上，人类传统的加密方法都是前一种，比如二战期间德军用的Enigma电报密码。莫尔斯电码也可以看作是一种私钥加密方法。

在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。
```
## MD5 
```
MD5是一个安全的散列算法，输入两个不同的明文不会得到相同的输出值，根据输出值，不能得到原始的明文，即其过程不可逆；所以要解密MD5没有现成的算法，只能用穷举法

应用：字符串指纹，防止被串改 ；登录认证等

```
## 非对称加密 RSA
```
  1、加密和解密的算法规则不一致
  
（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。

（2）甲方获取乙方的公钥，然后用它对信息加密。

（3）乙方得到加密后的信息，用私钥解密。


 2、 RSA 原理数学知识
  1、互质关系
  2、欧拉定理
  
 3、通俗点理解

```
## 非对称加密 理解
```
让对方任意想一个3位数，并把这个数和91相乘，然后告诉我积的最后三位数，我就可以猜出对方想的是什么数字啦！
比如对方想的是123，那么对方就计算出123 * 91等于11193，
并把结果的末三位193告诉我。
看起来，这么做似乎损失了不少信息，让我没法反推出原来的数。

不过，我仍然有办法：只需要把对方告诉我的结果再乘以11，乘积的末三位就是对方刚开始想的数了。
可以验证一下，193 * 11 = 2123，

末三位正是对方所想的秘密数字！
其实道理很简单，91乘以11等于1001，
而任何一个三位数乘以1001后，末三位显然都不变（例如123乘以1001就等于123123）。

知道原理后，我们可以构造一个定义域和值域更大的加密解密系统。
比方说，
任意一个数乘以400000001后，末8位都不变，而400000001 = 19801 * 20201，
于是你来乘以19801，我来乘以20201，又一个加密解密不对称的系统就构造好了。

甚至可以构造得更大一些：4000000000000000000000000000001 = 1199481995446957 * 3334772856269093，

这样我们就成功构造了一个30位的加密系统。这是一件非常coooooooool的事情，

任何人都可以按照我公布的方法加密一个数，但是只有我才知道怎么把所得的密文变回去。
其安全性就建立在算乘积非常容易，
但是要把4000000000000000000000000000001分解成后面两个数相乘，
在没有计算机的时代几乎不可能成功！

但如果仅仅按照上面的思路，如果对方知道原理，知道我要构造出带很多0的数，
根据19801和8位算法这2个条件非常容易穷举出400000001这个目标值。

要解决这个问题，真实世界就不是使用乘法了，
比如RSA算法使用的是指数和取模运算，但本质上就是上面这套思想。
```

## 算法的比较
* 对称加密算法

|名称|密钥长度|运算速度|安全性|资源消耗|
|:------:|---|--|--|--|
|DES| 56位| 较快| 低 |中|
|3DES| 112位或168位| 慢 |中 |高|
|AES |128、192、256位| 快| 高| 低|

* 非对称加密

|名称|成熟度|安全性(取决于密码长度）|运算速度|资源消耗|
|:------:|---|--|--|--|
|RSA| 高| 高| 慢 |慢|
|DSA| 高| 高 |快 |只能于数字签名|

* 对称与非对称算法比较 

|名称 |密钥管理 |安全性 |速度|
|----|----|----|----|
|对称算法 |比较难,不适合互联网,一般用于内部系统| 中| 快好几个数量级(软件加解密速度至少快100倍,每秒可以加解密数M比特数据),适合大数据量的加解密处理|
|非对称算法| 密钥容易管理| 高 |慢,适合小数据量加解密或数据签名|

## 参考资料
* [RSA 算法原理（1）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
* [RSA算法原理（2）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)